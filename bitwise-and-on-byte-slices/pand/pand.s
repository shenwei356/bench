// Code generated by command: go run asm.go -out pand.s -stubs stub.go. DO NOT EDIT.

#include "textflag.h"

// func PAND(x []byte, y []byte)
// Requires: AVX, AVX2
TEXT Â·PAND(SB), NOSPLIT|NOPTR, $0-48
	// pointer of x
	MOVQ x_base+0(FP), AX

	// length of x
	MOVQ x_len+8(FP), CX

	// pointer of y
	MOVQ y_base+24(FP), DX

	// --------------------------------------------
	VXORPD Y0, Y0, Y0
	VXORPD Y1, Y1, Y1
	VXORPD Y2, Y2, Y2
	VXORPD Y3, Y3, Y3

blockloop:
	// check number of left elements
	CMPQ CX, $0x00000080
	JL   loop32

	// compute bitwise AND and save the value back to *x
	VMOVAPD (AX), Y0
	VMOVAPD 32(AX), Y1
	VMOVAPD 64(AX), Y2
	VMOVAPD 96(AX), Y3
	VPAND   (DX), Y0, Y0
	VPAND   32(DX), Y1, Y1
	VPAND   64(DX), Y2, Y2
	VPAND   96(DX), Y3, Y3
	VMOVAPD Y0, (AX)
	VMOVAPD Y1, 32(AX)
	VMOVAPD Y2, 64(AX)
	VMOVAPD Y3, 96(AX)

	// move pointer
	ADDQ $0x00000080, AX
	ADDQ $0x00000080, DX

	// number of left elements
	SUBQ $0x00000080, CX
	JMP  blockloop

	// --------------------------------------------
	VXORPD Y0, Y0, Y0

loop32:
	// check number of left elements
	CMPQ CX, $0x00000020
	JL   loop8

	// compute bitwise AND and save the value back to *x
	VMOVAPD (AX), Y0
	VPAND   (DX), Y0, Y0
	VMOVAPD Y0, (AX)

	// move pointer
	ADDQ $0x00000020, AX
	ADDQ $0x00000020, DX

	// number of left elements
	SUBQ $0x00000020, CX
	JMP  loop32

	// --------------------------------------------
	XORQ BX, BX

loop8:
	// check number of left elements
	CMPQ CX, $0x00000008
	JL   end

	// compute bitwise AND and save the value back to *x
	MOVQ (AX), BX
	ANDQ (DX), BX
	MOVQ BX, (AX)

	// move pointer
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, DX

	// number of left elements
	SUBQ $0x00000008, CX
	JMP  loop8

	// --------------------------------------------
end:
	MOVQ (AX), BX
	ANDQ (DX), BX
	MOVQ BX, (AX)
	RET
